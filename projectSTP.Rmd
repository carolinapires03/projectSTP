---
title: ' Time Series and Forecasting Project'
author: "Bárbara Galiza 202408654; 
        Carolina Pires 202408704;
        Mariia Zhokhova 202408799"
        
subtitle: 'Analyse time series data'
output: html_notebook
institute: Faculdade de Ciências, Universidade do Porto
---

```{r}
library(tidyverse)
library(lubridate)
library(ggplot2)
library(forecast)
library(tseries)
library(ggcorrplot)
library(scales)
```

# Exploratory Data Analysis

```{r}
dataset <- read.csv("amazon_with_date.csv")
```

```{r}
head(dataset)
```

```{r}
summary(dataset)
```


```{r}
colSums(is.na(dataset))
```

```{r}
duplicados <- dataset[duplicated(dataset), ]
cat("Number of duplicate rows: ", nrow(duplicados), "\n")
```

```{r}
dataset_sem_duplicados <- dataset %>% distinct()
```

```{r}
cat("Número total de linhas após remover duplicados: ", nrow(dataset_sem_duplicados), "\n")
```

```{r}
dataset <- dataset_sem_duplicados
```

```{r}
dataset <- dataset %>%
  mutate(year = as.integer(year))
```

```{r}
str(dataset) 
```

#### Aggregate data by year

```{r}
annual_data <- dataset %>%
  group_by(year) %>%
  summarise(total_fires = sum(fires, na.rm = TRUE))
```

```{r}
head(annual_data)
```

```{r}
summary(annual_data$total_fires)
```

```{r}
ggplot(annual_data, aes(x = year, y = total_fires)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Annual Number of Forest Fires in Brazil",
       x = "year", y = "Number of fires") +
  theme_minimal()
```

```{r}
estados_unicos <- unique(dataset$state)

cat("Estados presentes no dataset:\n")
print(estados_unicos)
```
```{r}
cat("Total number of unique states:", length(estados_unicos), "\n")

frequencia_estados <- dataset %>%
  count(state) %>%
  arrange(desc(n))

cat("Frequency of occurrences by state:\n")
print(frequencia_estados)
```
```{r}
incendios_por_estado <- dataset %>%
  group_by(state) %>%
  summarise(total_incendios = sum(fires, na.rm = TRUE)) %>%
  arrange(desc(total_incendios))

cat("Total number of fires per state:\n")
print(incendios_por_estado)
```
```{r}
ggplot(incendios_por_estado, aes(x = reorder(state, -total_incendios), y = total_incendios)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Total number of fires per state",
       x = "States", y = "Number of fires") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
fires_ts <- ts(annual_data$total_fires, start = min(annual_data$year), frequency = 1)
```

```{r}
plot(fires_ts, main = "Time Series of Forest Fires in Brazil",
     xlab = "Year", ylab = "Number of fires", col = "blue", lwd = 2)
```
## State chosen: Mato Grosso

```{r}
mato_grosso_data <- dataset %>%
  filter(state == "MATO GROSSO DO SUL") %>%
  arrange(year, month)
```

```{r}
head(mato_grosso_data)
```

```{r}
ts_mato_grosso <- ts(mato_grosso_data$fires, 
                     start = c(min(mato_grosso_data$year), min(mato_grosso_data$month)), 
                     frequency = 12)
```


```{r}
plot(ts_mato_grosso, main = "Fire Time Series - Mato Grosso",
     xlab = "Year", ylab = "Number of fires", col = "blue", lwd = 2)
```
#### Aggregate data annually

```{r}
annual_mato_grosso <- mato_grosso_data %>%
  group_by(year) %>%
  summarise(total_fires = sum(fires, na.rm = TRUE))
```

```{r}
print(annual_mato_grosso)
```

```{r}
ts_mato_grosso_annual <- ts(annual_mato_grosso$total_fires, 
                            start = min(annual_mato_grosso$year), 
                            frequency = 1)
```

```{r}
plot(ts_mato_grosso_annual, main = "Annual Time Series of Fires - Mato Grosso",
     xlab = "Ano", ylab = "Number of fires", col = "darkblue", lwd = 2)
```

### Autocorrelation analysis

- Monthly data
```{r}
acf(ts_mato_grosso, main = "Autocorrelation Function (ACF)")
pacf(ts_mato_grosso, main = "Partial Autocorrelation Function (PACF)")
```

```{r}
adf_test_monthly <- adf.test(ts_mato_grosso, alternative = "stationary")
cat("ADF Test - p-value:", adf_test_monthly$p.value, "\n")
if (adf_test_monthly$p.value < 0.05) {
  cat("The monthly series is stationary based on the ADF test.\n")
} else {
  cat("The monthly series is not stationary based on the ADF test.\n")
}
```


- annual data

```{r}
acf(ts_mato_grosso_annual, main = "Autocorrelation Function (ACF)")
pacf(ts_mato_grosso_annual, main = "Partial Autocorrelation Function (PACF)")

```
```{r}
adf_test_annual <- adf.test(ts_mato_grosso_annual, alternative = "stationary")
cat("ADF Test (Anual) - p-value:", adf_test_annual$p.value, "\n")
if (adf_test_annual$p.value < 0.05) {
  cat("The annual series is stationary based on the ADF test.\n")
} else {
  cat("The annual series is not stationary based on the ADF test.\n")
}
```


```{r}
mato_grosso_agg <- mato_grosso_data %>%
  group_by(year) %>%
  summarise(total_fires = sum(fires, na.rm = TRUE))
```

```{r}
ggplot(mato_grosso_agg, aes(x = year, y = total_fires)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "red", size = 2) +
  labs(title = "Annual Evolution of Forest Fires - Mato Grosso",
       x = "Year", y = "Number of Fires") +
  theme_minimal()
```



```{r}
mato_grosso_agg <- mato_grosso_agg %>%
  mutate(change = c(NA, diff(total_fires))) 

ggplot(mato_grosso_agg, aes(x = year, y = change)) +
  geom_line(color = "purple", size = 1) +
  labs(title = "Annual Variation in the Number of Fires - Mato Grosso",
       x = "Year", y = "Change in the Number of Fires") +
  theme_minimal()
```


```{r}
decomp_mato_grosso <- decompose(ts_mato_grosso, type = "multiplicative")

plot(decomp_mato_grosso)
```

```{r}
trend_model <- lm(total_fires ~ year, data = annual_mato_grosso)

summary(trend_model)

annual_mato_grosso <- annual_mato_grosso %>%
  mutate(
    trend = predict(trend_model),       
    residuals = total_fires - trend     
  )

library(ggplot2)
ggplot(annual_mato_grosso, aes(x = year)) +
  geom_line(aes(y = total_fires, color = "Observed"), size = 1) +
  geom_line(aes(y = trend, color = "Trend"), linetype = "dashed", size = 1) +
  labs(title = "Observed vs Trend - Annual Fires in Mato Grosso",
       x = "Year", y = "Number of Fires") +
  scale_color_manual(name = "Legend", values = c("Observed" = "blue", "Trend" = "red")) +
  theme_minimal()

ggplot(annual_mato_grosso, aes(x = year, y = residuals)) +
  geom_line(color = "purple", size = 1) +
  labs(title = "Residuals of Annual Fires - Mato Grosso",
       x = "Year", y = "Residuals") +
  theme_minimal()
```
### seasonality 


```{r}
ggplot(mato_grosso_data, aes(x = as.factor(month), y = fires)) +
  geom_boxplot() +
  labs(title = "Monthly Seasonality - Mato Grosso", x = "Month", y = "Number of Fires") +
  theme_minimal()
```
```{r}
monthplot(ts_mato_grosso)
```
```{r}
seasonplot(ts_mato_grosso)

```

### Seasonal Moving Averages

```{r}
moving_avg <- mato_grosso_data %>%
  arrange(year, month) %>%
  mutate(moving_avg = zoo::rollmean(fires, k = 12, fill = NA))

ggplot(moving_avg, aes(x = as.Date(paste(year, month, 1, sep = "-")), y = moving_avg)) +
  geom_line(color = "blue") +
  labs(title = "12-Month Moving Average", x = "Date", y = "Moving Average of Fires") +
  theme_minimal()
```


```{r}
# 4. Regression with Trend and Seasonality
dummies_model <- tslm(ts_mato_grosso ~ trend + season)
summary(dummies_model)

autoplot(ts_mato_grosso, series="Data") +
  autolayer(fitted(dummies_model), series="Fitted") +
  xlab("Year") + ylab("Number of Fires") +
  ggtitle("Fitted Trend and Seasonality - Mato Grosso")

plot(residuals(dummies_model), main = "Detrended Desasonalized Data - Mato Grosso", type="l", col="blue")
```
```{r}
# 5. Fourier Series for Seasonality
fourier_model <- tslm(ts_mato_grosso ~ trend + fourier(ts_mato_grosso, K=2))
summary(fourier_model)

autoplot(ts_mato_grosso, series="Data") +
  autolayer(fitted(fourier_model), series="Fitted") +
  xlab("Year") + ylab("Number of Fires") +
  ggtitle("Fitted Fourier Model - Mato Grosso")

plot(residuals(fourier_model), main = "Detrended Desasonalized Data - Fourier - Mato Grosso", type="l", col="blue")
seasonplot(residuals(fourier_model))
```
```{r}
# Seasonal Differencing
par(mfrow=c(2,1))
plot(ts_mato_grosso, main="Original Series", type="l", col="blue")
plot(diff(ts_mato_grosso, 12), main="Seasonally Differenced Series", type="l", col="red")
monthplot(diff(ts_mato_grosso, 12))
```
```{r}
library(scales)
```

```{r}
# Removing Both Trend and Seasonality
par(mfrow=c(2,1))
plot(ts_mato_grosso, main="Original Series", type="l", col="blue")
plot(diff(diff(ts_mato_grosso), 12), main="Trend and Seasonally Differenced Series", type="l", col="red")
acf(diff(diff(ts_mato_grosso), 12), main="ACF of Trend and Seasonally Differenced Series")
```

```{r}
# 8. STL Decomposition
mato_grosso_stl_per <- stl(ts_mato_grosso, s.window="periodic")
mato_grosso_stl <- stl(ts_mato_grosso, s.window=13)
plot(mato_grosso_stl_per)
plot(mato_grosso_stl)
```

```{r}
# Extracting Time Series Components
head(mato_grosso_stl_per$time.series, 24)
head(mato_grosso_stl$time.series, 24)
```

```{r}
# Applying STL to Mato Grosso Data
plot(mato_grosso_stl)
```

```{r}
# Correlation Behavior in Remainder
acf(ts_mato_grosso, main="ACF of Original Series")
acf(mato_grosso_stl$time.series[,3], main="ACF of Remainder")
```

### Dividing the data into training and test

```{r}
train_mato_grosso <- window(ts_mato_grosso, end = c(2015, 12)) 
test_mato_grosso <- window(ts_mato_grosso, start = c(2016, 1))
```

```{r}
plot(train_mato_grosso, 
     main = "Training Set - Mato Grosso", 
     ylab = "Number of fires", 
     xlab = "Year", 
     col = "darkgreen", 
     lwd = 2)

plot(test_mato_grosso, 
     main = "Test Set - Mato Grosso", 
     ylab = "Number of fires", 
     xlab = "Year", 
     col = "orange", 
     lwd = 2)
```

### Modelo ARIMA
```{r}
#arima_model <- auto.arima(ts_mato_grosso)
#summary(arima_model)

#forecast_arima <- forecast(arima_model, h = 12)
#plot(forecast_arima)
```

Apply logarithm because of hetecedasticity:
```{r}
library(forecast)
shift_value <- 1 - min(train_mato_grosso)
train_mato_grosso_shifted <- train_mato_grosso + shift_value

ly = log(train_mato_grosso_shifted)
plot(ly, 
     main = "Training Set (logged) - Mato Grosso", 
     ylab = "Number of fires", 
     xlab = "Year", 
     col = "darkgreen", 
     lwd = 2)

# Calculate the optimal lambda for Box-Cox transformation
lambda <- BoxCox.lambda(train_mato_grosso_shifted)

# Apply the Box-Cox transformation
by <- BoxCox(train_mato_grosso_shifted, lambda)

# Plot the transformed time series
plot(
  by,
  main = "Training Set (BoxCox) - Mato Grosso",
  ylab = "Number of Fires",
  xlab = "Year",
  col = "darkgreen",
  lwd = 2
)
```
ADF test
```{r}
adf_test_train <- adf.test(ly, alternative = "stationary")
cat("ADF Test - p-value:", adf_test_train$p.value, "\n")
if (adf_test_train$p.value < 0.05) {
  cat("The monthly series is stationary based on the ADF test.\n")
} else {
  cat("The monthly series is not stationary based on the ADF test.\n")
}

kpss_test_train <- kpss.test(ly, null = "Level")
cat("KPSS Test - p-value:", kpss_test_train$p.value, "\n")
if (kpss_test_train$p.value < 0.05) {
  cat("The monthly series is NOT stationary based on the KPSS test.\n")
} else {
  cat("The monthly series is stationary based on the KPSS test.\n")
}
```
The tests indicate stationarity. Use ndiffs and nsdiffs:
```{r}
nsdiffs(ly)
ndiffs(ly)
```

Series is not stationary, needs differiencing. d = 0, D = 1.
```{r}
dly1 = diff(ly,1)
dly12 = diff(ly,12)
dly12_1 = diff(diff(ly,12),1)
```

```{r}
maxlag <- 48
par(mfrow=c(3,4), mar=c(3,3,4,2))

plot(ly, main = expression("log(y)"))
plot(dly1, main = expression(paste(Delta, "log(y)")))
plot(dly12, main = expression(paste(Delta[12], "log(y)")))
plot(dly12_1, main = expression(paste(Delta, Delta[12], "log(y)")))

Acf(ly, type='correlation', lag=maxlag, ylab="", main=expression(paste("ACF for log(y)")))
Acf(dly1, type='correlation', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("ACF for ", Delta,"log(y)")))
Acf(dly12, type='correlation', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("ACF for ", Delta[12], "log(y)")))
Acf(dly12_1, type='correlation', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("ACF for ", Delta, Delta[12], "log(y)")))

Acf(ly, type='partial', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("PACF for log(y)")))
Acf(dly1, type='partial', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("PACF for ", Delta, "log(y)")))
Acf(dly12, type='partial', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("PACF for ", Delta[12], "log(y)")))
Acf(dly12_1, type='partial', lag=maxlag, na.action=na.omit, ylab="", main=expression(paste("PACF for ", Delta,Delta[12], "log(y)")))
```

Although the ndiffs and nsdiffs tests indicated d = 0 and D = 1, the ACF and PACF of D=1 and d=1 shows a more stationary series. So we will test for both d = 1 and d = 0. For the MA and AR components, for the d = 0 we propose q = 0, p = 1 or 2, P = 1, given the significant lag 12 at the PACF, and Q = 0. For d = 1, we propose q = 1, p = 0, Q = 1 (lag 12 on ACF) and P = 1. Also, s = 12.

Models SARIMA(p,d,q)x(P,D,Q)s to try:
SARIMA(1,0,0)x(1,1,0)12
SARIMA(2,0,0)x(1,1,0)12
SARIMA(0,1,1)x(1,1,1)12

```{r}
library(astsa)
m1=sarima(ly,1,0,0,1,1,0,12)
```
The residuals from model 1 show autocorrelation
```{r}
m2=sarima(ly,2,0,0,1,1,0,12)
```
Seems like a good fit, with all the p-values from Ljung-Box being above 0.05, meaning the residuals are independent, and the ACF of residuals show they are mostly uncorrelated.
```{r}
m3=sarima(ly,0,1,1,1,1,1,12)
```
Not a good fit given the Ljung-Box statistic.

M2 was the best fit. We must investigate if the parameters are significant:
```{r}
m2
```
Constant is not significant

```{r}
m21 = sarima(ly, 2, 0, 0, 1, 1, 0, 12, no.constant = TRUE)
```
```{r}
m21
```
Now all the parameters are significant.
```{r}
acf2(m21$fit$residuals)
```
There is still some correlation left on the PACF, lets try variations of mod4.
```{r}
m22 = sarima(ly, p = 3, d = 0, q = 0, P = 1, D = 1, Q = 0, S = 12, no.constant = TRUE)
acf2(m22$fit$residuals)
```
AR3 not significant. Lets try q = 1

```{r}
m23 = sarima(ly, p = 2, d = 0, q = 1, P = 1, D = 1, Q = 0, S = 12, no.constant = TRUE)
acf2(m22$fit$residuals)
```
Still the same problem with PACF and non significant coefficients. Better to stick with model21.
```{r}
m21
```
Final model: SARIMA(2,0,0)x(1,1,0)12 with no constant (full formula on the report).

The AIC of mod21 was lower than most models, just not lower than mod3. However, mod3 did not meet the residuals assumptions, so mod21 can be considered the model with lowest AIC (and BIC) out of the more adequate models, such as mod2, mod21, mod22 and mod23.




